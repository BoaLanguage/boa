open Ast
open Pprint

(* Values include *closures*, which are functions including their environments
   at "definition time." We also have "lazy" values, which let us delay the
   evaluation of expressions to support recursion. *)

(* Interpreter exceptions. *)
type error_info = string
exception IllformedExpression of error_info
exception UnboundVariable of var
exception IllegalBreak
exception IllegalContinue
exception IllegalReturn
exception TypecheckerFail of error_info 

(* A type for configurations. *)
type configuration = 
  env * stmt * stmt * ((stmt * stmt * stmt) list)

let make_configuration (prog: stmt) : configuration = 
  ([], prog, Pass, [])
(* A function to update the binding for x in env s.
   update (s, x, v) returns the env s[x->v]. *)
let rec update s x v =
  match s with
  | [] ->
    [(x, v)]
  | (y ,u)::t ->
    if x = y then (x, v)::t
    else (y, u)::(update t x v)

let rec take n lst =
  match lst, n with
  | el::rest, n when n > 0 -> el::(take (n - 1) rest)
  | _ -> []

(* A function to look up the binding for a variable in a env.
   lookup s x returns s(x) or UnboundVariable if s is not defined on s. *)
let rec lookup s x : value =
  match s with
  | [] ->
    raise (UnboundVariable x)
  | (y,u)::t ->
    if x = y then u
    else (lookup t x)

let rec lookup_opt s x : value =
  match s with
  | [] ->
    raise (UnboundVariable x)
  | (y,u)::t ->
    if x = y then 
      (match u with 
      | Some v -> v
      | _ -> failwith "TYPECHECK FAIL")
    else (lookup_opt t x)

let rec lookup_value vdict vkey : value = 
    match vdict with
    | [] -> failwith "No member of that name/val"
    | (k, v)::rest -> 
      if k = vkey then v
      else lookup_value rest vkey

let int_of_value (v : value) : int =
  match v with
  | VInt i -> i
  | _ ->  failwith "BIG PROBLEM"

let bool_of_value (v : value) : bool = 
  match v with
  | VBool b -> b
  | _ -> failwith "BIG PROBLEM"

let rec pow (a : int) (b : int) : int = 
  if (b = 0) then 1 else 
  if (b = 1) then a else pow (a * a) (b - 1)

let evalb (b : binop) (l : value) (r : value) : value = 
  match b with
  | Plus -> VInt((int_of_value l) + (int_of_value r))
  | Less -> VBool((int_of_value l) < (int_of_value r))
  | Greater -> VBool((int_of_value l) > (int_of_value r))
  | And -> VBool((bool_of_value l) && (bool_of_value r))
  | Or -> VBool((bool_of_value l) || (bool_of_value r))
  | Equal -> VBool((int_of_value l) = (int_of_value r))
  | Times -> VInt((int_of_value l) * (int_of_value r))
  | Minus -> VInt((int_of_value l) - (int_of_value r))
  | Divide -> VInt((int_of_value l) / (int_of_value r))
  | Mod -> VInt((int_of_value l) mod (int_of_value r))
  | Exponent -> VInt(pow (int_of_value l) (int_of_value r))
  | IntDivide -> VInt((int_of_value l) / (int_of_value r))
  | Leq -> VBool((int_of_value l) <= (int_of_value r))
  | Geq -> VBool((int_of_value l) >= (int_of_value r))
  | Is -> VBool((int_of_value l) = (int_of_value r))
  | In -> failwith "unimplemented"
  | Neq -> VBool((int_of_value l) <> (int_of_value r))

let eval_fun (f: stmt) (e: env) : value = 
  match f with
  | Def (_, v, arg_type_lst, statement) -> 
    (
      let args = List.map snd arg_type_lst in
      let e' = ref e in 
      let closure = VClosure(args, statement, e') in 
      e' := (v, closure)::e; closure      
    )
  | _-> failwith "TYPECHECKERFAIL"

let rec evale (e : exp) (s : env) : value =
  let evaluate_var v =
    let lookup_result = lookup s v in   
    match lookup_result with 
    | VRef vr->
    begin
      match !vr with 
      | Some v -> v
      | None -> raise @@ TypecheckerFail "Uninitialized"
    end
    | _ -> lookup_result in 
  let evaluate_application callable_expression args = 
    call (evale callable_expression s) (List.map (fun f -> f s) (List.map (evale) args)) in 
  let evaluate_attribute_access object_expression attribute_identifier = 
    let obj_val = evale object_expression s in
    let obj = extract_class obj_val in
    let cls_ref = (extract_class (lookup obj "__class__")) in 
    let res = lookup (obj@cls_ref) attribute_identifier in
    match res with 
    | VClosure (_, _, _) -> VMethodCall (obj_val, res) (** Bind object to self *)
    | v -> deref_value v in
  let evaluate_slice_access sliceable_expression index_expression = 
    (* let obj = evale sliceable_expression s in  *)
    (* match obj with 
    | VDict o -> call (lookup_value o (VString("__slice__"))) ([arg])
    | _ -> call (evaluate_attribute_access sliceable_expression "__slice__") [arg] in *)
    let arg = evale index_expression s in
    call (evaluate_attribute_access sliceable_expression "__slice__") [arg] in
  let evaluate_unary_operator operator operand = 
    let operand_value = evale operand s in
    match operator, operand_value with 
    | Not, VBool b -> VBool (not b)
    | Neg, VInt i -> VInt (-i)
    | _, _ -> raise @@ TypecheckerFail "Unary Operator Application" in
  let evaluate_tuple expression_list = 
    let value_lst = List.map (fun expression -> evale expression s) expression_list in
    VTuple (value_lst) in
  let evaluate_list = evaluate_tuple in
  let evaluate_dict kv_expression_list = 
    let kv_value_list = 
      List.map (fun (k,v) -> evale k s, evale v s) kv_expression_list in 
    VDict kv_value_list in 
  match e with
  | Var identifier -> evaluate_var identifier 
  | Call (fn, args) -> evaluate_application fn args
  | AttrAccess (e, v) -> evaluate_attribute_access e v
  | SliceAccess (e1, e2) -> evaluate_slice_access e1 e2      
  | Binary (bin, e1, e2) -> evalb bin (evale e1 s) (evale e2 s)
  | Int i -> VInt(i)
  | Unary (operator, operand) -> evaluate_unary_operator operator operand 
  | Bool b -> VBool(b)
  | Tuple explist -> evaluate_tuple explist
  | List explist -> evaluate_list explist
  | Dict expexplist -> evaluate_dict expexplist
  | Skip -> VNone
  | Lam (v, t, e) -> VClosure ([v], Return(e), ref s)
  | _ -> failwith "Unimplemented: Expression"

  
and evals (conf:configuration) : env =
  let sigma, current_statement, next_statement, kappa = conf in
  match current_statement, next_statement with
  | Pass, Pass -> sigma
  | Pass, c -> evals (sigma, c, Pass, kappa)
  | Assign(v, a), c ->
    begin
    let n = evale a sigma in 
    let new_sigma = 
    (match List.assoc_opt v sigma with 
    | Some (VRef r) -> r := Some n; sigma 
    | _ -> (v, n)::sigma)      
    in evals (new_sigma, c, Pass, kappa)
    end
  | AttrAssgn(objexp, attr, e), c ->
    begin
      let v = evale e sigma in 
      let obj = evale objexp sigma in
      (match obj with 
      | VPreObj(old_obj) -> 
          (match List.assoc_opt attr old_obj with 
          | Some (result) -> 
          begin
            result := v;
            evals (sigma, c, Pass, kappa)
          end
          | _ -> failwith "Unbound attribute")
      | VObj obj -> 
        begin
        let _ = 
          (match List.assoc_opt attr obj with
          | Some (result) -> 
            (match result with 
            | VRef value -> value := (Some v)
            | _ -> failwith "Immutable Attribute")
          | _ -> failwith "Unbound Attribute")      
          in evals (sigma, c, Pass, kappa)
        end
      
      | _ -> print_value obj; ("TYPECHECK FAIL: " ^ attr) |> failwith)
    end
  | Decl (_, _), c -> evals (sigma, Pass, c, kappa)
  | MutableDecl (_, v), c -> 
    evals ((v, VRef (ref None))::sigma, c, Pass, kappa)
  | MemDecl(_, v), c -> 
      let attrs = lookup sigma "__attrs__" in 
      (match attrs with 
      | VList lst -> let new_sigma = update sigma "__attrs__" (VList((VString(v))::lst)) in 
        evals (new_sigma, Pass, c, kappa) 
      | _ -> failwith "TYPECHECK FAILED: ATTRS NOT A LIST")
  | MutableMemDecl(_, v), c -> 
      let mattrs = lookup sigma "__mattrs__" in 
      (match mattrs with 
      | VList lst -> let new_sigma = update sigma "__mattrs__" (VList(((VString(v))::lst))) in 
        evals (new_sigma, Pass, c, kappa) 
      | _ -> failwith "TYPECHECK FAILED: MATTRS NOT A LIST")
  | Block(c1::t), Pass -> evals (sigma, c1, Block(t), kappa)
  | Block(c1::t), c3 -> evals (sigma, c1, Block(t@[c3]), kappa)
  
  | Block([]), c3 -> evals (sigma, Pass, c3, kappa)

  | If(b,c1,c2), c3 -> let b_result = evale b sigma in 
    (match b_result with
    | VBool b' -> if b' 
      then evals (sigma, c1, c3, kappa) 
      else evals (sigma, c2, c3, kappa)
    | _-> failwith "If guard must be a boolean")

  | While(b, c1), c2 -> 
    let b_result = evale b sigma in 
    begin
    match b_result with
    | VBool b' -> if b' 
      then 
        let w = While(b, c1) in 
        let s_continue = Block([w;c2]) in 
        let s_break = c2 in
        let s_return = 
          (match kappa with 
          | [] -> Pass  
          | (_,_, s)::t -> s) in 
        evals (sigma, c1, Block([w;c2]), (s_break, s_continue, s_return)::kappa)
      else evals (sigma, Pass, c2, kappa)
    | _ -> raise @@ TypecheckerFail "While guard must be a boolean"
    end
  | Print(a), c -> let n = evale a sigma in 
    Pprint.print_value n; Format.printf "%s" "\n"; evals (sigma, Pass, c, kappa)

  | Break, c -> 
  begin
    match kappa with 
    | (c_b, c_c, _)::kappa_t ->  evals (sigma, c_b, Pass, kappa_t)
    | _ -> raise IllegalBreak
  end
  | Continue, c -> 
  begin
    match kappa with
    | (c_b, c_c, _)::kappa_t -> evals (sigma, c_c, Pass, kappa_t)
    | _ -> raise IllegalContinue
  end
  | Return e, _->  ("return", evale e sigma)::sigma
  | Def (rt, name, args, body), c -> 
    evals ((name, eval_fun (Def (rt, name, args, body)) sigma)::sigma, Pass, c, kappa)
  | Class (name, super, stmt), c ->
    let new_sigma = ("__mattrs__", VList([]))::("__attrs__", VList([]))::sigma in
    let obj_dict = evals (new_sigma, stmt, Pass, []) in
    let new_dict = (take (List.length obj_dict - List.length sigma)) obj_dict in
    let clobj = VObj(new_dict) in
    (* let clobj = VObj((name, VRef (ref (Some(clobj))))::new_dict) in *)
    evals ((name, VRef (ref (Some(clobj))))::sigma, c, Pass, kappa)
  | _ -> failwith "unimplemented"

and call (vclosure : value) (args : value list) : value = 
  let zip p a = (p, a) in
  match vclosure with 
  | VMethodCall (obj, closure) -> 
    (
      match call (closure) (obj::args) with
      | VRef r -> 
      begin
        match !r with
        | Some v -> v
        | _ -> failwith "Method returned none"
      end
      | v -> v
    )
  | VClosure (params, body, env_ref) -> 
  let callenv = 
    (match args with 
    | [] -> !env_ref
    | _ -> 
    (List.map2 zip params args)@(!env_ref)) in 
    lookup (evals (callenv, body, Pass, [])) "return"
  | VRef r -> 
    (match !r with 
    | Some (VObj(cls_obj) as v) -> call v args
    | _ -> failwith "Not good")
  | VObj cls_obj -> 
  begin
    match (lookup cls_obj "__init__") with
    | VClosure (params, body, env) as init -> 
    let attrs = lookup cls_obj "__attrs__" in 
    let mattrs = lookup cls_obj "__mattrs__" in
    let extract_string_list vlist = 
      (match vlist with 
      | VList (val_list) -> 
        let extract_string vstring = 
          (match vstring  with
          | VString s -> s
          | _ -> failwith "INFRASTRUCTURE FAIL") in
        List.map extract_string val_list
      | _ -> failwith "INFRASTRUCTURE FAILLLL") in 
    let attrs', mattrs' = extract_string_list attrs, extract_string_list mattrs in
    let preinit_attrs = List.map (fun x -> (x, ref VNone)) (attrs'@mattrs') in
    let cls_ref = [("__class__", ref (VRef (ref (Some (VObj cls_obj)))))] in
    let initial_obj_list = preinit_attrs@cls_ref in
    let instance = VPreObj(initial_obj_list) in 
    let new_args = (VRef (ref (Some instance)))::args in
    (match call init new_args with 
      | VPreObj(attrsmattrs) -> 
        let attrs = 
          List.filter (fun (name, vref) -> List.mem name attrs') attrsmattrs in
        let attrs = 
          List.map (fun (name, vref) -> (name, !vref)) attrs in
        let mattrs = List.filter (fun (name, vref) -> List.mem name mattrs') attrsmattrs in
        let mattrs =  List.map (fun (name, vref) -> (name, VRef (ref (Some !vref)))) mattrs in
          VObj([("__class__", VRef(ref (Some (VObj(cls_obj)))))]@attrs@mattrs)
    | _ -> failwith "Infra fail")
    | _ -> failwith "Typecheck fail"
  end 
  
  | _ -> failwith "TYPECHECK FAIL"

  (*
      let new_env: env = ("class", VObj(cls_obj))::(!env) in
      call (VClosure(List.tl params, body, ref new_env)) args ) *)
  and extract_class value = 
  match value with 
  | VRef r -> 
  begin
    match !r with
    | Some (VObj (cls_ref)) -> cls_ref
    | _ -> failwith "not a class"
  end
  | VObj(cls_ref) -> cls_ref
  | _ -> failwith "Not a class"

  and deref_value value =
  match value with 
  | VRef r -> 
    (match !r with 
    | Some v -> v
    | None -> failwith "Fail")
  | _ -> value